#include <iostream>
#include <cmath>
#include <vector>
#include <fstream>
#include <optional>
#include <limits>
#include <algorithm>

#include "geometry.h"


class Sphere {
public:
	Sphere(const Vec3f &c, const float &r, const Vec3f &col) : center(c), radius(r), color(col) {}

	std::optional<float> intersect(const Vec3f &orig, const Vec3f &dir) const
	{
		float t0, t1;
		std::optional<float> t;
		Vec3f L = orig - center;
		float a = dir.dotProduct(dir);
		float b = 2 * L.dotProduct(dir);
		float c = L.dotProduct(L) - radius * radius;

		float disc = b * b - 4 * a * c;

		if (disc == 0)
			t = b * -0.5f * a;
		else if (disc > 0) {
			float q = -0.5f * (b > 0 ?
				b + std::sqrt(disc) :
				b - std::sqrt(disc));
			t0 = q / a;
			t1 = c / q;
			if (t0 > t1) std::swap(t0, t1);
			t = t0;
		}

		return t;
	}

	Vec3f center;
	float radius;
	Vec3f color;
};


bool trace(const Vec3f &orig, const Vec3f &dir, const std::vector<Sphere> &spheres, float &tNear, const Sphere *&hitSphere)
{
	tNear = std::numeric_limits<float>::max();

	for (auto &sphere : spheres) {
		auto t = sphere.intersect(orig, dir);
		if (t.has_value() && tNear > t.value()) {
			hitSphere = &sphere;
			tNear = t.value();
		}
	}

	return (hitSphere != nullptr);
}

Vec3f castRay(const Vec3f &orig, Vec3f &dir, const std::vector<Sphere> &spheres)
{
	float t;
	const Sphere *hitSphere = nullptr;

	if (trace(orig, dir, spheres, t, hitSphere)) {
		Vec3f pHit = orig + t * dir;
		Vec3f normalRay = (pHit - hitSphere->center).normalize();
		return hitSphere->color;
	}

	return Vec3f(0.69f, 0.13f, 0.13f);
}

void render(const std::vector<Sphere> &spheres)
{
	const int width = 1024;
	const int height = 768;
	const float fov = 90;
	const float imageAspectRatio = width / (float)height;
	const float scale = tan(fov * 0.5f * (float)pi / 180);

	auto *framebuffer = new Vec3f[width * height];
	Vec3f *pix = framebuffer;

	for (size_t i = 0; i < height; i++) {
		for (size_t k = 0; k < width; k++) {
			float x = (2 * (k + 0.5f) / width - 1) * imageAspectRatio * scale;
			float y = (1 - (2 * (i + 0.5f) / height)) * scale;
			Vec3f dir = Vec3f(x, y, -1).normalize();
			*(pix++) = castRay(Vec3f(0, 0, 0), dir, spheres);
		}
	}

	std::ofstream ofs;
	ofs.open("./out.ppm", std::ofstream::out | std::ofstream::binary);
	ofs << "P6\n" << width << " " << height << "\n255\n";

	for (size_t i = 0; i < width * height; ++i) {
		char r = (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i].x)));
		char g = (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i].y)));
		char b = (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i].z)));
		ofs << r << g << b;
	}

	ofs.close();

	delete[] framebuffer;
}

int main()
{
	std::vector<Sphere> spheres;

	Vec3f ivory(0.4f, 0.4f, 0.3f);
	Vec3f cream(1.f, 0.98f, 0.82f);

	spheres.push_back(Sphere(Vec3f(-3, 0, -16), 2, ivory));
	spheres.push_back(Sphere(Vec3f(-1., -1.5, -12), 2, cream));
	spheres.push_back(Sphere(Vec3f(1.5, -0.5, -18), 3, cream));
	spheres.push_back(Sphere(Vec3f(7, 5, -18), 4, ivory));

	render(spheres);

	return 0;
}
